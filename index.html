<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Oiltoken — Voice Connect</title>
  <style>
    :root{ --bg:#0b1220; --card:#0f1724; --muted:#9aa4b2; --accent:#3b82f6; }
    *{box-sizing:border-box}
    body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#071126 0%,#0b1220 100%);color:#e6eef8;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px}
    .wrap{max-width:980px;width:100%}
    .card{background:var(--card);border-radius:14px;padding:22px;box-shadow:0 10px 40px rgba(2,6,23,0.6)}
    h1{margin:0 0 6px;font-size:22px}
    p.lead{margin:0;color:var(--muted)}
    .controls{margin-top:18px;display:flex;gap:10px;flex-wrap:wrap}
    button{background:linear-gradient(90deg,var(--accent),#2563eb);border:none;color:white;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
    input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid #233240;background:#081023;color:#e6eef8;margin-top:10px}
    .status{margin-top:12px;color:var(--muted);font-size:13px}
    audio{width:100%;margin-top:12px;border-radius:8px;background:#000}
    /* modal */
    #modal{display:none;position:fixed;inset:0;background:rgba(2,6,23,0.7);align-items:center;justify-content:center;z-index:80}
    .modal-box{background:#071428;padding:18px;border-radius:12px;max-width:420px;width:92%;box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    .modal-box h3{margin:0 0 8px}
    .muted{color:var(--muted);font-size:13px}
    .kbd{background:#0b1730;padding:6px 8px;border-radius:6px;font-family:monospace;font-size:12px}
    .footer{margin-top:14px;font-size:12px;color:var(--muted);text-align:center}
    a.link{color:#9ad0ff}
    pre.configPreview{margin-top:10px;background:#031124;padding:10px;border-radius:8px;color:#bfe6ff;white-space:pre-wrap;font-size:12px;max-height:180px;overflow:auto}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" id="mainCard">
      <h1>Oiltoken — Instant Voice Call</h1>
      <p class="lead">Peer-to-peer voice calls using WebRTC and Firestore signaling. No admin/login required.</p>

      <div class="controls">
        <button id="openModalBtn">Open Call Modal</button>
        <button id="reloadConfigBtn" class="ghost">Reload Firebase Config</button>
      </div>

      <div class="status" id="status">Status: waiting for firebase config...</div>

      <div style="margin-top:14px" id="callArea" class="hidden">
        <label class="muted">Remote audio</label>
        <audio id="remoteAudio" controls autoplay></audio>
        <div class="status" id="callStatus"></div>
      </div>

      <div class="footer">
        Make sure your Firebase project has Authentication (optional) and Firestore enabled.<br>
        Config is fetched from a raw GitHub URL you provided.
      </div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modal" role="dialog" aria-modal="true">
    <div class="modal-box">
      <h3>Start or Join a Voice Call</h3>
      <p class="muted">Create a new call (gives you a Call ID) or paste an existing Call ID to join.</p>

      <input id="callIdField" type="text" placeholder="(leave empty to create new call)" />
      <div style="display:flex;gap:8px;margin-top:10px">
        <button id="createBtn">Create Call</button>
        <button id="joinBtn" class="ghost">Join Call</button>
        <button id="closeModal" class="ghost">Close</button>
      </div>

      <div class="muted" style="margin-top:12px">Firebase config source:</div>
      <div class="kbd" id="configSource" style="margin-top:6px;overflow:auto;max-width:100%"></div>

      <div style="margin-top:10px">
        <div class="muted">If automatic load fails, paste the firebase config (JSON) here:</div>
        <textarea id="manualConfig" style="width:100%;height:90px;margin-top:8px;border-radius:8px;background:#04122a;color:#cfeeff;padding:8px;border:1px solid #0a2b44"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="applyManualConfig">Apply Config</button>
          <button id="clearManualConfig" class="ghost">Clear</button>
        </div>
        <div id="manualHint" class="muted" style="margin-top:8px"></div>
      </div>

      <pre id="configPreview" class="configPreview" hidden></pre>
    </div>
  </div>

  <script type="module">
    // -------------------------
    // CONFIG: raw URL (from user)
    // -------------------------
    // NOTE: this exact URL was provided by you. Including it in client pages exposes it to users.
    // You asked the page to read from this address; the script will attempt to inject it as a <script>.
    const RAW_CONFIG_URL = "https://raw.githubusercontent.com/Oiltokenofficail/private-config.js/refs/heads/main/private-config.js?token=GHSAT0AAAAAADMPW6UZ5JHWC2N6MAK3UV2O2HQYHOA";

    // -------------------------
    // UI elements
    // -------------------------
    const statusEl = document.getElementById('status');
    const openModalBtn = document.getElementById('openModalBtn');
    const modal = document.getElementById('modal');
    const closeModal = document.getElementById('closeModal');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const callIdField = document.getElementById('callIdField');
    const configSource = document.getElementById('configSource');
    const manualConfig = document.getElementById('manualConfig');
    const applyManualConfig = document.getElementById('applyManualConfig');
    const clearManualConfig = document.getElementById('clearManualConfig');
    const configPreview = document.getElementById('configPreview');
    const reloadConfigBtn = document.getElementById('reloadConfigBtn');
    const callArea = document.getElementById('callArea');
    const callStatus = document.getElementById('callStatus');
    const remoteAudio = document.getElementById('remoteAudio');

    configSource.textContent = RAW_CONFIG_URL;

    openModalBtn.addEventListener('click', () => { modal.style.display = 'flex'; });
    closeModal.addEventListener('click', () => { modal.style.display = 'none'; });

    // -------------------------
    // Helpers & state
    // -------------------------
    let firebaseApp = null;
    let db = null;
    let pc = null;
    let localStream = null;
    const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    function setStatus(txt) { statusEl.textContent = "Status: " + txt; }
    function setCallStatus(txt) { callStatus.textContent = txt; }

    // -------------------------
    // Try to load the remote config by injecting a script tag.
    // This lets the fetched file itself set window.__FIREBASE_CONFIG if it uses that pattern.
    // If injection fails (CORS/403/404), fallback to fetch() and try to parse JSON or JS.
    // -------------------------
    async function loadRemoteConfig() {
      setStatus("loading firebase config from remote URL...");
      configPreview.hidden = true;
      // First attempt: inject script tag
      try {
        await new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = RAW_CONFIG_URL;
          s.async = true;
          s.onload = () => resolve();
          s.onerror = (e) => reject(new Error('Script load failed'));
          document.head.appendChild(s);
          // remove tag after some time to keep DOM clean
          setTimeout(() => { if (s.parentNode) s.parentNode.removeChild(s); }, 3000);
        });
        // If the remote script used window.__FIREBASE_CONFIG, it should be set now.
        if (window.__FIREBASE_CONFIG && window.__FIREBASE_CONFIG.projectId) {
          setStatus("firebase config loaded (script injection).");
          configPreview.hidden = false;
          configPreview.textContent = JSON.stringify(window.__FIREBASE_CONFIG, null, 2);
          return window.__FIREBASE_CONFIG;
        } else {
          // injection succeeded but config not present: fallback to fetch
          setStatus("script loaded but config not found; attempting fetch fallback...");
        }
      } catch (e) {
        // injection failed; try fetch
        console.warn("Script injection failed:", e);
        setStatus("script injection failed; attempting fetch...");
      }

      // Second attempt: fetch content and try to parse
      try {
        const resp = await fetch(RAW_CONFIG_URL, { cache: "no-store" });
        if (!resp.ok) throw new Error("Fetch failed: " + resp.status);
        const text = await resp.text();
        // Try to extract JSON-like object from text
        // Many private-config.js files define window.__FIREBASE_CONFIG = { ... };
        const jsonMatch = text.match(/\{[\s\S]*\}/m);
        if (jsonMatch) {
          const objText = jsonMatch[0];
          try {
            const cfg = JSON.parse(objText);
            window.__FIREBASE_CONFIG = cfg;
            configPreview.hidden = false;
            configPreview.textContent = JSON.stringify(cfg, null, 2);
            setStatus("firebase config loaded (fetch & parsed JSON).");
            return cfg;
          } catch (parseErr) {
            // If it isn't valid JSON (comments or trailing commas), present to user to paste manually
            configPreview.hidden = false;
            configPreview.textContent = text.slice(0, 2000) + (text.length > 2000 ? "\n\n...truncated..." : "");
            setStatus("fetch succeeded but config is not valid JSON; paste manually if needed.");
            return null;
          }
        } else {
          configPreview.hidden = false;
          configPreview.textContent = text.slice(0, 2000) + (text.length > 2000 ? "\n\n...truncated..." : "");
          setStatus("fetch succeeded but no JSON object found; paste config manually.");
          return null;
        }
      } catch (err) {
        console.warn("Fetch failed:", err);
        setStatus("failed to load config from remote URL (network/CORS). Paste config manually.");
        return null;
      }
    }

    // -------------------------
    // Initialize Firebase (once config available)
    // -------------------------
    async function initFirebaseAndFirestore(cfg) {
      if (!cfg || !cfg.projectId) { setStatus("no config provided"); return false; }
      try {
        // Dynamically import Firebase modules (CDN)
        const mod = await import("https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js");
        const fsMod = await import("https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js");
        firebaseApp = mod.initializeApp(cfg);
        db = fsMod.getFirestore(firebaseApp);
        setStatus("firebase initialized (project: " + (cfg.projectId || "unknown") + ").");
        return true;
      } catch (e) {
        console.error("Firebase init failed:", e);
        setStatus("firebase initialization failed: " + e.message);
        return false;
      }
    }

    // -------------------------
    // WebRTC + Firestore signaling functions
    // -------------------------
    async function ensureLocalAudio() {
      if (localStream) return localStream;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        setCallStatus("Microphone access granted.");
        return localStream;
      } catch (e) {
        setCallStatus("Microphone access denied: " + (e.message || e));
        throw e;
      }
    }

    function createPeerConnection() {
      pc = new RTCPeerConnection(servers);
      pc.ontrack = (ev) => {
        // attach first incoming stream to audio element
        remoteAudio.srcObject = ev.streams[0];
        callArea.classList.remove('hidden');
      };
      pc.onconnectionstatechange = () => {
        setCallStatus("Peer connection state: " + pc.connectionState);
      };
      return pc;
    }

    // create call: creates Firestore doc with offer; writes offerCandidates
    async function createCall() {
      if (!db) { setCallStatus("No Firestore DB"); return; }
      await ensureLocalAudio();
      createPeerConnection();
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      const { collection, doc, setDoc, addDoc, onSnapshot } = await import("https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js");

      const callsCol = collection(db, "calls");
      const callDocRef = doc(callsCol); // random id
      const offerCandidatesCol = collection(callDocRef, "offerCandidates");
      const answerCandidatesCol = collection(callDocRef, "answerCandidates");

      pc.onicecandidate = (e) => {
        if (e.candidate) addDoc(offerCandidatesCol, e.candidate.toJSON());
      };

      const offerDesc = await pc.createOffer();
      await pc.setLocalDescription(offerDesc);

      await setDoc(callDocRef, { offer: { type: offerDesc.type, sdp: offerDesc.sdp, createdAt: Date.now() } });

      // listen for remote answer
      onSnapshot(callDocRef, (snap) => {
        const data = snap.data();
        if (!pc.currentRemoteDescription && data && data.answer) {
          pc.setRemoteDescription(new RTCSessionDescription(data.answer)).catch(console.error);
        }
      });

      // listen for answer ICE candidates
      onSnapshot(answerCandidatesCol, (snap) => {
        snap.docChanges().forEach(change => {
          if (change.type === "added") {
            const c = change.doc.data();
            pc.addIceCandidate(new RTCIceCandidate(c)).catch(console.error);
          }
        });
      });

      setCallStatus("Call created. Call ID: " + callDocRef.id);
      return callDocRef.id;
    }

    // join call by id
    async function joinCall(callId) {
      if (!db) { setCallStatus("No Firestore DB"); return false; }
      await ensureLocalAudio();
      createPeerConnection();
      localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      const { collection, doc, getDoc, onSnapshot, addDoc, updateDoc } = await import("https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js");

      const callDocRef = doc(db, "calls", callId);
      const callSnap = await getDoc(callDocRef);
      if (!callSnap.exists()) { setCallStatus("Call ID not found"); return false; }
      const data = callSnap.data();

      const offerCandidatesCol = collection(callDocRef, "offerCandidates");
      const answerCandidatesCol = collection(callDocRef, "answerCandidates");

      pc.onicecandidate = e => {
        if (e.candidate) addDoc(answerCandidatesCol, e.candidate.toJSON());
      };

      // add any offer candidates
      onSnapshot(offerCandidatesCol, (snap) => {
        snap.docChanges().forEach(change => {
          if (change.type === "added") {
            pc.addIceCandidate(new RTCIceCandidate(change.doc.data())).catch(console.error);
          }
        });
      });

      const offerDesc = new RTCSessionDescription(data.offer);
      await pc.setRemoteDescription(offerDesc);

      const answerDesc = await pc.createAnswer();
      await pc.setLocalDescription(answerDesc);

      await updateDoc(callDocRef, { answer: { type: answerDesc.type, sdp: answerDesc.sdp, createdAt: Date.now() } });

      // listen for remote tracks via pc.ontrack (already set)
      setCallStatus("Joined call: " + callId);
      return true;
    }

    // -------------------------
    // UI wiring
    // -------------------------
    createBtn.addEventListener('click', async () => {
      try {
        setCallStatus("Creating call...");
        const id = await createCall();
        if (id) {
          callIdField.value = id;
          alert("Call created. Share this Call ID with the other party:\n\n" + id);
          modal.style.display = 'none';
        }
      } catch (e) {
        console.error(e);
        setCallStatus("Error creating call: " + e.message);
      }
    });

    joinBtn.addEventListener('click', async () => {
      const id = callIdField.value.trim();
      if (!id) { setCallStatus("Please enter a Call ID to join"); return; }
      try {
        setCallStatus("Joining call...");
        const ok = await joinCall(id);
        if (ok) modal.style.display = 'none';
      } catch (e) {
        console.error(e);
        setCallStatus("Error joining: " + e.message);
      }
    });

    applyManualConfig.addEventListener('click', async () => {
      const text = manualConfig.value.trim();
      if (!text) { manualHint.textContent = "Paste the firebase config JSON object."; return; }
      try {
        // Try to parse JSON
        const parsed = JSON.parse(text);
        window.__FIREBASE_CONFIG = parsed;
        configPreview.hidden = false;
        configPreview.textContent = JSON.stringify(parsed, null, 2);
        setStatus("Manual config applied. Initializing...");
        const ok = await initFirebaseAndFirestore(parsed);
        if (ok) setStatus("Ready. You can create or join calls.");
      } catch (e) {
        manualHint.textContent = "Invalid JSON: " + e.message;
      }
    });

    clearManualConfig.addEventListener('click', () => {
      manualConfig.value = "";
      manualHint.textContent = "";
    });

    reloadConfigBtn.addEventListener('click', async () => {
      setStatus("Reloading remote config...");
      const cfg = await loadRemoteConfig();
      if (cfg) {
        const ok = await initFirebaseAndFirestore(cfg);
        if (ok) setStatus("Ready. Create or join calls.");
      }
    });

    // -------------------------
    // Boot: attempt to load config, then initialize
    // -------------------------
    (async function boot() {
      configSource.textContent = RAW_CONFIG_URL;
      const cfg = await loadRemoteConfig();
      if (cfg) {
        const ok = await initFirebaseAndFirestore(cfg);
        if (ok) setStatus("Ready. Open the modal and create or join a call.");
      } else {
        setStatus("No usable config loaded. Paste config into the modal and click Apply.");
        modal.style.display = 'flex';
      }
    })();

    // expose small helper for debugging
    window._Oiltoken = {
      RAW_CONFIG_URL,
      loadRemoteConfig,
      initFirebaseAndFirestore
    };
  </script>
</body>
</html>
